#!/usr/bin/env ruby

## FIXME: Replace this code with a pure Ruby clone of the ls utility
# system("ls", *ARGV)
require "optparse"
require "etc"

# Intentionally keeping everything in the same file for simplicity. In prod version I'd split this into multiple files.
module RLs
  class Application
    def initialize(argv)
      @options, @args = parse_arguments(argv)
      @display = Display.new(@options)
    end

    def run
      if @args.empty?
        # List current directory
        list_directory
      else
        # List each file or directory passed as an argument
        @args.each do |path|
          list_single_entry(path)
        end
      end
    end

    def list_directory(path = ".")
      entries = @options[:list_all] ? 
        Dir.entries(path).sort : 
        Dir.glob("*", base: path, sort: true)
      entries = entries.map { |entry| {:name => entry, :stat => File.stat(path + "/" + entry)} }
      render_entries(entries)
    end

    def list_single_entry(path)
      raise "#{path}: No such file or directory" unless File.exist?(path)
      
      if File.directory?(path)
        list_directory(path)
      else
        render_entry({:name => path, :stat => File.stat(path)})
      end      
    end

    def render_entries(entries)
      if @options[:list]
        total_blocks, max_size = entries.reduce([0, 0]) do |acc, entry|
          acc[0] += entry[:stat].blocks
          acc[1] = [acc[1], entry[:stat].size].max
          acc
        end

        size_formatting = max_size.to_s.size + 1 # +1 for padding
        puts "total #{total_blocks}"
      end


      entries.each do |entry|
        render_entry(entry, size_formatting)
      end
    end

    def render_entry(entry, size_formatting = 3)
      if skip?(entry)
        return
      end

      
      if @options[:list]
        stat = entry[:stat]
        extended_attr = has_extended_attributes?(entry) ? '@' : ''
        puts "#{get_file_type(entry)}#{mode_to_permissions_string(stat.mode)}#{extended_attr} #{stat.nlink} #{Etc.getpwuid(stat.uid).name} #{Etc.getgrgid(stat.gid).name.rjust(6)} #{stat.size.to_s.rjust(size_formatting)} #{stat.mtime.strftime("%b %d %H:%M")} #{entry[:name]}"
      else
        puts entry[:name]
      end

      
    end

    def get_file_type(entry)
      # Get file type
      case
      when entry[:stat].directory? then 'd'
      when entry[:stat].symlink? then 'l'
      when entry[:stat].pipe? then 'p'
      when entry[:stat].socket? then 's'
      when entry[:stat].chardev? then 'c'
      when entry[:stat].blockdev? then 'b'
      else '-'
      end
    end

    def mode_to_permissions_string(mode)
      # Get permissions
      perms = ''
      # Owner permissions
      perms << (mode & 0o400 != 0 ? 'r' : '-')
      perms << (mode & 0o200 != 0 ? 'w' : '-')
      perms << (mode & 0o100 != 0 ? 'x' : '-')
      # Group permissions
      perms << (mode & 0o040 != 0 ? 'r' : '-')
      perms << (mode & 0o020 != 0 ? 'w' : '-')
      perms << (mode & 0o010 != 0 ? 'x' : '-')
      # Others permissions
      perms << (mode & 0o004 != 0 ? 'r' : '-')
      perms << (mode & 0o002 != 0 ? 'w' : '-')
      perms << (mode & 0o001 != 0 ? 'x' : '-')

      perms
    end

    def skip?(entry)
      @options[:list_all] ? false : entry[:name].start_with?(".")
    end

    def parse_arguments(argv)
      options = {}
      args = []
      parser = OptionParser.new

      parser.on("-l") { options[:list] = true }
      parser.on("-a") { options[:list_all] = true }
      args = parser.parse(argv)
      
      [options, args]
    end

    def has_extended_attributes?(entry)
      `xattr -l "#{entry[:name]}" 2>/dev/null`
      $?.success?
    end
  end

  # This class is responsible for rendering the entries in the correct format.
  class Display
    def initialize(options)
      @options = options
    end
    
    def render_entries(entries)
      
    end
  end
end

begin
  RLs::Application.new(ARGV).run
rescue OptionParser::InvalidOption => e
  # Have to rewrite message to match ls formatting
  message = "invalid option -- #{e.args.map { |arg| arg.gsub('-', '') }.join(', ')}"
  abort "ls: #{message}\nusage: ls [-@ABCFGHILOPRSTUWXabcdefghiklmnopqrstuvwxy1%,] [--color=when] [-D format] [file ...]"
rescue StandardError => e
  abort "ls: #{e.message}"
end 